#!/bin/bash
# Script to download VMCA cert, create tokens, generate configs, process dashboards.
# Assumes internal TLS certs are already generated by certs-setup container.
# Expects OUTPUT_DIR, INPUT_DASH_DIR, INFLUXDB_TOKEN, INFLUXDB_ORG, VCENTER_URL etc.

set -e
# set -x # Uncomment for extreme debugging

# --- Configuration Variables ---
echo "--- Config Generation Script Starting ---"
date

INFLUXDB_API_BASE_URL="https://influxdb:8086" # HTTPS
CERT_OUTPUT_BASE_DIR="${OUTPUT_DIR}/certs"
INTERNAL_CERT_DIR="${CERT_OUTPUT_BASE_DIR}/internal" # Where internal certs *were* generated
VCENTER_CA_OUTPUT_PATH="${CERT_OUTPUT_BASE_DIR}/vcenter-ca.pem"
# Path where this container mounts the internal CA cert generated by certs-setup
INTERNAL_CA_CERT_PATH_FOR_CURL="/etc/ssl/certs/tig_internal_ca.pem" # Path for THIS container's curl
# Path where Telegraf container will mount the internal CA cert
TELEGRAF_INTERNAL_CA_PATH="/etc/telegraf/certs/internal/ca.pem"
# Fixed UID for the Grafana Datasource
GRAFANA_DATASOURCE_UID="influxdb_vmware_ds"
# Define Operator token from environment for clarity
OPERATOR_TOKEN="${INFLUXDB_TOKEN}"
# Temporary file base name
TMP_BASE="/tmp/setup_$$_$RANDOM"


# --- Dependency Checks and Installation ---
ensure_packages() {
    local missing_pkg=0
    echo "Checking required packages: curl jq unzip bash..."
    for pkg in curl jq unzip bash; do
        if ! command -v $pkg &> /dev/null; then
            echo "Package '$pkg' not found. Attempting to install..."
            if ! apk add --no-cache $pkg; then
                 echo "Error: Failed to install '$pkg'. Exiting." >&2
                 exit 1
            fi
            missing_pkg=1
        fi
    done
    if [ $missing_pkg -eq 0 ]; then
        echo "All required packages are present."
    fi
    # Check if CA cert is mounted for curl verification
    if [ ! -f "$INTERNAL_CA_CERT_PATH_FOR_CURL" ]; then
        echo "Error: Internal CA certificate not found at $INTERNAL_CA_CERT_PATH_FOR_CURL. Cannot verify InfluxDB API." >&2
        # Attempt to wait briefly in case mount is slow?
        sleep 2
        if [ ! -f "$INTERNAL_CA_CERT_PATH_FOR_CURL" ]; then
             echo "Error: Internal CA certificate still not found after wait. Exiting." >&2
             exit 1
        fi
        echo "Info: Internal CA certificate found after short delay."
    fi
}

# --- Download vCenter VMCA Certificate ---
download_vmca_cert() {
    local vcenter_url="${VCENTER_URL}"
    local output_path="${VCENTER_CA_OUTPUT_PATH}"
    local output_dir
    output_dir=$(dirname "$output_path")
    if [ -z "$vcenter_url" ]; then echo "Warning: VCENTER_URL not set. Cannot download VMCA certificate." >&2; return 1; fi
    if [ -f "$output_path" ]; then echo "vCenter CA certificate '$output_path' already exists, skipping download."; return 0; fi
    local vcenter_host
    vcenter_host=$(echo "$vcenter_url" | sed -e 's|^https\?://||' -e 's|/sdk$||' -e 's|/.*$||')
    if [ -z "$vcenter_host" ]; then echo "Error: Could not parse vCenter host/IP from URL: $vcenter_url" >&2; return 1; fi
    local download_url="http://${vcenter_host}/certs/download.zip"
    local zip_file="${TMP_BASE}_vmca.zip"
    local extract_dir="${TMP_BASE}_vmca_extract"
    echo "Attempting to download VMCA certs from $download_url..."
    mkdir -p "$output_dir" "$extract_dir"
    if ! command -v curl &> /dev/null; then echo "Error: curl not found!" >&2; exit 1; fi
    if ! command -v unzip &> /dev/null; then echo "Error: unzip not found!" >&2; exit 1; fi
    curl -L -k --connect-timeout 10 --max-time 30 -o "$zip_file" "$download_url"
    CURL_EXIT_CODE=$?
    if [ $CURL_EXIT_CODE -ne 0 ] || [ ! -s "$zip_file" ]; then echo "Error: Failed to download VMCA cert bundle from $download_url (curl code: $CURL_EXIT_CODE)." >&2; rm -f "$zip_file"; rm -rf "$extract_dir"; return 1; fi
    echo "Extracting certificate..."
    unzip -o "$zip_file" -d "$extract_dir" >> /dev/null; rm -f "$zip_file"
    local cert_files
    cert_files=$(find "$extract_dir/certs/lin/" -type f \( -name "*.crt" -o -name "*.[0-9]" \) -print)
    if [ -z "$cert_files" ]; then echo "Error: Could not find Linux CA certificate(s) in extracted files." >&2; rm -rf "$extract_dir"; return 1; fi
    echo "Found VMCA certificate file(s): $cert_files"
    cat $cert_files > "$output_path"; rm -rf "$extract_dir"
    if [ -s "$output_path" ]; then echo "VMCA certificate(s) successfully saved to $output_path"; return 0; else echo "Error: Failed to save VMCA certificate(s) to $output_path" >&2; return 1; fi
}

# --- API Helper Functions (Use TLS + Internal CA) ---
_api_call() {
    local method="$1"; local url="$2"; local token="$3"; local data_payload="$4"
    local body_file="${TMP_BASE}_body.out"; local status_file="${TMP_BASE}_status.out"
    local http_status CURL_EXIT_CODE body
    # Use the CA path mounted for THIS container's curl
    local curl_opts=("-sS" "-f" "-w" "%{http_code}" "-o" "${body_file}" "--cacert" "${INTERNAL_CA_CERT_PATH_FOR_CURL}")
    local headers=("--header" "Authorization: Token ${token}")
    if [[ "$method" == "POST" || "$method" == "PUT" || "$method" == "PATCH" ]]; then headers+=("--header" "Content-type: application/json"); curl_opts+=("-X" "$method" "--data" "${data_payload}"); else curl_opts+=("-X" "GET"); fi
    echo "DEBUG: API Call - Method: $method, URL: $url"
    curl "${curl_opts[@]}" "${headers[@]}" "${url}" > "${status_file}"
    CURL_EXIT_CODE=$?
    if [ $CURL_EXIT_CODE -ne 0 ]; then echo "Error: curl command failed (Method: ${method}, URL: ${url}) with exit code ${CURL_EXIT_CODE}." >&2; cat "${status_file}" >&2 ; rm -f "${body_file}" "${status_file}"; exit 1; fi
    http_status=$(cat "${status_file}" | sed 's/[^0-9]*//g'); body=$(cat "${body_file}"); rm -f "${body_file}" "${status_file}";
    echo "DEBUG: API Call Response - HTTP Status: '${http_status}'"; echo "DEBUG: API Call Response - Raw Body (length ${#body}):"; echo "'${body}'"
    _API_CALL_STATUS=$http_status; _API_CALL_BODY=$body # Return via global vars
}

# --- Functions using _api_call ---
get_org_id() {
    local org_name=$1; echo "Fetching Org ID for ${org_name}..."; local api_url="${INFLUXDB_API_BASE_URL}/api/v2/orgs?org=${org_name}"; _api_call "GET" "$api_url" "$OPERATOR_TOKEN"; http_status=$_API_CALL_STATUS; body=$_API_CALL_BODY
    if [ "$http_status" -ne 200 ]; then echo "Error: Failed to get Org ID. Status: ${http_status}" >&2; exit 1; fi; if [ -z "$body" ]; then echo "Error: Received empty body for Org ID." >&2; exit 1; fi
    ORG_ID=$(echo "${body}" | jq -r '.orgs[0].id'); JQ_EXIT_CODE=$?; if [ $JQ_EXIT_CODE -ne 0 ]; then echo "Error: jq failed parsing Org ID response (Exit: ${JQ_EXIT_CODE}). Body: '${body}'" >&2; exit 1; fi
    if [ -z "$ORG_ID" ] || [ "$ORG_ID" == "null" ]; then echo "Error: Could not extract Org ID using jq. Body: '${body}'" >&2; exit 1; fi; echo "Found Org ID: ${ORG_ID}"
}

get_bucket_id() {
    local bucket_name=$1; local org_identifier=$2; echo "Fetching Bucket ID for ${bucket_name} in Org ID ${org_identifier}..."; local api_url="${INFLUXDB_API_BASE_URL}/api/v2/buckets?name=${bucket_name}&orgID=${org_identifier}"; _api_call "GET" "$api_url" "$OPERATOR_TOKEN"; http_status=$_API_CALL_STATUS; body=$_API_CALL_BODY
    if [ "$http_status" -ne 200 ]; then echo "Error: Failed to get Bucket ID. Status: ${http_status}" >&2; exit 1; fi; if [ -z "$body" ]; then echo "Error: Received empty body for Bucket ID." >&2; exit 1; fi
    BUCKET_ID=$(echo "${body}" | jq -r '.buckets[0].id'); JQ_EXIT_CODE=$?; if [ $JQ_EXIT_CODE -ne 0 ]; then echo "Error: jq failed parsing Bucket ID response (Exit: ${JQ_EXIT_CODE}). Body: '${body}'" >&2; exit 1; fi
    if [ -z "$BUCKET_ID" ] || [ "$BUCKET_ID" == "null" ]; then echo "Error: Could not extract Bucket ID using jq. Body: '${body}'" >&2; exit 1; fi; echo "Found Bucket ID: ${BUCKET_ID}"
}

create_telegraf_token() {
    echo "Creating Telegraf-specific InfluxDB Token (Write-Only)..."; local api_url="${INFLUXDB_API_BASE_URL}/api/v2/authorizations"; local description="Telegraf Write Token for Bucket ${INFLUXDB_BUCKET}"; local json_payload
    json_payload=$(jq -n --arg orgID "$ORG_ID" --arg bucketID "$BUCKET_ID" --arg desc "$description" \ '{orgID: $orgID, description: $desc, permissions: [{"action": "write", "resource": {"type": "buckets", "id": $bucketID, "orgID": $orgID}}]}'); echo "DEBUG: Telegraf Token Payload: $json_payload"
    _api_call "POST" "$api_url" "$OPERATOR_TOKEN" "$json_payload"; http_status=$_API_CALL_STATUS; body=$_API_CALL_BODY
    if [ "$http_status" -ne 201 ]; then echo "Error: Failed to create Telegraf token! Status: ${http_status}" >&2; exit 1; fi; if [ -z "$body" ]; then echo "Error: Received empty body for Telegraf token creation." >&2; exit 1; fi
    TELEGRAF_TOKEN=$(echo "${body}" | jq -r '.token'); JQ_EXIT_CODE=$?; local token_id=$(echo "${body}" | jq -r '.id'); if [ $JQ_EXIT_CODE -ne 0 ]; then echo "Error: jq failed parsing Telegraf token response (Exit: ${JQ_EXIT_CODE}). Body: '${body}'" >&2; exit 1; fi
    if [ -z "$TELEGRAF_TOKEN" ] || [ "$TELEGRAF_TOKEN" == "null" ]; then echo "Error: Failed to extract Telegraf token from API response. Body: '${body}'" >&2; exit 1; fi; echo "Successfully created Telegraf Write Token ID: ${token_id}"
}

create_grafana_token() {
     echo "Creating Grafana-specific InfluxDB Token (Read-Only)..."; local api_url="${INFLUXDB_API_BASE_URL}/api/v2/authorizations"; local description="Grafana Read Token for Bucket ${INFLUXDB_BUCKET}"; local json_payload
     json_payload=$(jq -n --arg orgID "$ORG_ID" --arg bucketID "$BUCKET_ID" --arg desc "$description" \ '{orgID: $orgID, description: $desc, permissions: [{"action": "read", "resource": {"type": "buckets", "id": $bucketID, "orgID": $orgID}}]}'); echo "DEBUG: Grafana Token Payload: $json_payload"
     _api_call "POST" "$api_url" "$OPERATOR_TOKEN" "$json_payload"; http_status=$_API_CALL_STATUS; body=$_API_CALL_BODY
     if [ "$http_status" -ne 201 ]; then echo "Error: Failed to create Grafana token! Status: ${http_status}" >&2; exit 1; fi; if [ -z "$body" ]; then echo "Error: Received empty body for Grafana token creation." >&2; exit 1; fi
     GRAFANA_READ_TOKEN=$(echo "${body}" | jq -r '.token'); JQ_EXIT_CODE=$?; local token_id=$(echo "${body}" | jq -r '.id'); if [ $JQ_EXIT_CODE -ne 0 ]; then echo "Error: jq failed parsing Grafana token response (Exit: ${JQ_EXIT_CODE}). Body: '${body}'" >&2; exit 1; fi
     if [ -z "$GRAFANA_READ_TOKEN" ] || [ "$GRAFANA_READ_TOKEN" == "null" ]; then echo "Error: Failed to extract Grafana token from API response! Body: '${body}'" >&2; exit 1; fi; echo "Successfully created Grafana Read Token ID: ${token_id}"
}

# --- Generate Telegraf Config (Uses Telegraf Token + TLS) ---
generate_telegraf_config() {
    echo "Generating Telegraf output config (TLS enabled)..."
    mkdir -p "${OUTPUT_DIR}/telegraf"
    # --- Use CORRECT Path for tls_ca ---
    local telegraf_internal_ca_path="${TELEGRAF_INTERNAL_CA_PATH}" # Use variable defined at top
    cat << EOF > "${OUTPUT_DIR}/telegraf/influxdb_output.conf"
# Configuration generated by setup script
[[outputs.influxdb_v2]]
  urls = ["${INFLUXDB_API_BASE_URL}"] # Use https URL
  token = "${TELEGRAF_TOKEN}" # Use the dedicated Telegraf write token
  organization = "${INFLUXDB_ORG}"
  bucket = "${INFLUXDB_BUCKET}"
  ## TLS config for talking to InfluxDB
  tls_ca = "${telegraf_internal_ca_path}" # Use the correct path for Telegraf container mount
  insecure_skip_verify = false # Verify internal cert
EOF
    echo "Telegraf config written to ${OUTPUT_DIR}/telegraf/influxdb_output.conf"
}

# --- Generate Grafana Datasource Config (Uses Grafana Token + TLS) ---
generate_grafana_config() {
    echo "Generating Grafana datasource config (TLS enabled, using system trust)..." # Updated log
    # REMOVED: ca_cert_content logic is no longer needed

    mkdir -p "${OUTPUT_DIR}/grafana-datasource"
    cat << EOF > "${OUTPUT_DIR}/grafana-datasource/influxdb_datasource.yml"
# Configuration generated by setup script
apiVersion: 1

datasources:
  - name: InfluxDB-VMware
    uid: ${GRAFANA_DATASOURCE_UID}
    type: influxdb
    access: proxy
    url: ${INFLUXDB_API_BASE_URL} # Use https URL
    jsonData:
      version: Flux
      organization: ${INFLUXDB_ORG}
      defaultBucket: ${INFLUXDB_BUCKET}
      tlsSkipVerify: false # VERIFY internal cert using system trust store
      # REMOVED: tlsCACert line - CA cert managed by entrypoint now
    secureJsonData:
      token: ${GRAFANA_READ_TOKEN} # Use the Grafana read-only token
    editable: true
EOF
    echo "Grafana datasource written to ${OUTPUT_DIR}/grafana-datasource/influxdb_datasource.yml"
}

# --- Process Dashboard JSON Files ---
# Function in setup-scripts/setup_configs.sh

process_dashboards() {
    local input_dir="${INPUT_DASH_DIR:-/dashboards-input}"
    local output_dir="${OUTPUT_DIR}/grafana-dashboards"

    # --- CORRECTED Check ---
    # Use standard shell tests: -d checks if it's a directory, -r checks if it's readable
    if [ ! -d "$input_dir" ] || [ ! -r "$input_dir" ]; then
        echo "Warning: Input dashboard directory '$input_dir' not found or not readable. Skipping dashboard processing."
        return # Keep return here, maybe directory genuinely doesn't exist/isn't mounted
    fi
    # --- End CORRECTED Check ---

    echo "Processing dashboard JSON files from '$input_dir' to '$output_dir'..."
    # ... rest of the function remains the same ...
    mkdir -p "$output_dir";
    if ! command -v jq &> /dev/null; then echo "Error: jq not found for dashboard processing." >&2; exit 1; fi
    find "$input_dir" -maxdepth 1 -name '*.json' -print | while IFS= read -r input_file; do
        local filename; filename=$(basename "$input_file"); local output_file="$output_dir/$filename";
        echo "  Processing $filename -> $output_file";
        jq \
            --arg uid "$GRAFANA_DATASOURCE_UID" \
            '(.. | select(type == "object" and .uid == "${DS_INFLUXDB}").uid) |= $uid | del(.__inputs[]? | select(.name == "DS_INFLUXDB")) | if .__inputs? | length == 0 then del(.__inputs) else . end' \
            "$input_file" > "$output_file";
        if [ $? -ne 0 ]; then echo "Error processing $filename with jq." >&2; fi;
    done;
    echo "Dashboard processing complete."
}

# --- Main Execution ---
echo "Starting main config/token/dashboard script execution..."
ensure_packages # Check/install needed tools

# Attempt to download VMCA cert (best effort)
VMCA_DOWNLOAD_SUCCESS=1 # Assume failure
download_vmca_cert && VMCA_DOWNLOAD_SUCCESS=0 # Set to 0 on success

# Check Operator Token is set
if [ -z "$OPERATOR_TOKEN" ]; then echo "Error: INFLUXDB_TOKEN env var is not set!" >&2; exit 1; fi

# Get InfluxDB Org/Bucket IDs using Operator Token and generated CA for TLS
get_org_id "${INFLUXDB_ORG}"
get_bucket_id "${INFLUXDB_BUCKET}" "${ORG_ID}"

# Create specific tokens
create_telegraf_token
create_grafana_token

# Generate configuration files using specific tokens and TLS settings
generate_telegraf_config
generate_grafana_config

# Process dashboards
process_dashboards

echo "--- Configuration and Dashboard Processing Script Finished Successfully ---"
date
if [ "$VMCA_DOWNLOAD_SUCCESS" -ne 0 ]; then
    echo "Warning: Failed to automatically download VMCA certificate. Telegraf vSphere input might fail TLS verification unless the cert is manually placed at ${VCENTER_CA_OUTPUT_PATH} or retrieved/trusted by other means."
fi
exit 0